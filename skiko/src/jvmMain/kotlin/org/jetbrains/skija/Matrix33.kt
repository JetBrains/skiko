// Generated by delombok at Mon Aug 30 12:25:17 MSK 2021
package org.jetbrains.skija

import org.jetbrains.skija.impl.Library.Companion.staticLoad
import org.jetbrains.annotations.ApiStatus
import org.jetbrains.skija.impl.RefCnt
import org.jetbrains.skija.impl.Managed.CleanerThunk
import org.jetbrains.skija.paragraph.Shadow
import org.jetbrains.skija.paragraph.TextBox
import org.jetbrains.skija.paragraph.Affinity
import org.jetbrains.skija.ManagedString
import org.jetbrains.skija.paragraph.Paragraph
import org.jetbrains.skija.IRange
import org.jetbrains.skija.FontFeature
import org.jetbrains.skija.Typeface
import org.jetbrains.skija.paragraph.HeightMode
import org.jetbrains.skija.paragraph.StrutStyle
import org.jetbrains.skija.paragraph.BaselineMode
import org.jetbrains.skija.paragraph.RectWidthMode
import org.jetbrains.skija.paragraph.FontCollection
import org.jetbrains.skija.FontMgr
import org.jetbrains.skija.paragraph.ParagraphCache
import org.jetbrains.skija.paragraph.ParagraphStyle
import org.jetbrains.skija.paragraph.RectHeightMode
import org.jetbrains.skija.paragraph.DecorationStyle
import org.jetbrains.skija.paragraph.ParagraphBuilder
import org.jetbrains.skija.paragraph.PlaceholderStyle
import org.jetbrains.skija.paragraph.TextStyleAttribute
import org.jetbrains.skija.paragraph.DecorationLineStyle
import org.jetbrains.skija.paragraph.PlaceholderAlignment
import org.jetbrains.skija.paragraph.PositionWithAffinity
import org.jetbrains.skija.paragraph.TypefaceFontProvider
import org.jetbrains.skija.shaper.Shaper
import org.jetbrains.skija.TextBlob
import org.jetbrains.skija.shaper.FontRun
import org.jetbrains.skija.FourByteTag
import org.jetbrains.skija.shaper.LanguageRun
import org.jetbrains.skija.shaper.ShapingOptions
import org.jetbrains.skija.shaper.FontMgrRunIterator
import org.jetbrains.skija.shaper.IcuBidiRunIterator
import org.jetbrains.skija.shaper.ManagedRunIterator
import org.jetbrains.skija.shaper.HbIcuScriptRunIterator
import org.jetbrains.skija.shaper.TextBlobBuilderRunHandler
import org.jetbrains.annotations.ApiStatus.OverrideOnly
import org.jetbrains.skija.skottie.Animation
import org.jetbrains.skija.sksg.InvalidationController
import org.jetbrains.skija.skottie.RenderFlag
import org.jetbrains.skija.skottie.AnimationBuilder
import org.jetbrains.skija.skottie.AnimationBuilderFlag
import org.jetbrains.skija.Matrix33
import org.jetbrains.skija.svg.SVGDOM
import org.jetbrains.skija.svg.SVGSVG
import org.jetbrains.skija.svg.SVGTag
import org.jetbrains.skija.svg.SVGNode
import org.jetbrains.skija.WStream
import org.jetbrains.skija.svg.SVGCanvas
import org.jetbrains.skija.svg.SVGLength
import org.jetbrains.skija.svg.SVGLengthType
import org.jetbrains.skija.svg.SVGLengthUnit
import org.jetbrains.skija.svg.SVGLengthContext
import org.jetbrains.skija.svg.SVGPreserveAspectRatio
import org.jetbrains.skija.svg.SVGPreserveAspectRatioAlign
import org.jetbrains.skija.svg.SVGPreserveAspectRatioScale
import org.jetbrains.skija.ColorAlphaType
import org.jetbrains.skija.AnimationDisposalMode
import org.jetbrains.skija.BlendMode
import org.jetbrains.skija.IRect
import org.jetbrains.skija.AnimationFrameInfo
import org.jetbrains.skija.BackendRenderTarget
import org.jetbrains.skija.IHasImageInfo
import org.jetbrains.skija.ImageInfo
import org.jetbrains.skija.IPoint
import org.jetbrains.skija.PixelRef
import org.jetbrains.skija.Shader
import org.jetbrains.skija.FilterTileMode
import org.jetbrains.skija.SamplingMode
import org.jetbrains.skija.U16String
import org.jetbrains.skija.SurfaceProps
import org.jetbrains.skija.RRect
import org.jetbrains.skija.ClipMode
import org.jetbrains.skija.FilterMode
import org.jetbrains.skija.Picture
import org.jetbrains.skija.Matrix44
import org.jetbrains.skija.EncodedOrigin
import org.jetbrains.skija.EncodedImageFormat
import org.jetbrains.skija.Color4f
import org.jetbrains.skija.ColorChannel
import org.jetbrains.skija.ColorFilter
import org.jetbrains.skija.ColorMatrix
import org.jetbrains.skija.ColorFilter._LinearToSRGBGammaHolder
import org.jetbrains.skija.ColorFilter._SRGBToLinearGammaHolder
import org.jetbrains.skija.InversionMode
import org.jetbrains.skija.ColorFilter._LumaHolder
import org.jetbrains.skija.ColorInfo
import org.jetbrains.skija.ColorSpace._SRGBHolder
import org.jetbrains.skija.ColorSpace._SRGBLinearHolder
import org.jetbrains.skija.ColorSpace._DisplayP3Holder
import org.jetbrains.skija.ContentChangeMode
import org.jetbrains.skija.CubicResampler
import org.jetbrains.skija.DirectContext
import org.jetbrains.skija.GLBackendState
import org.jetbrains.annotations.ApiStatus.NonExtendable
import org.jetbrains.annotations.Contract
import org.jetbrains.skija.FilterBlurMode
import org.jetbrains.skija.MipmapMode
import org.jetbrains.skija.FilterMipmap
import org.jetbrains.skija.FilterQuality
import org.jetbrains.skija.FontEdging
import org.jetbrains.skija.FontHinting
import org.jetbrains.skija.FontExtents
import org.jetbrains.skija.FontFamilyName
import org.jetbrains.skija.FontMgr._DefaultHolder
import org.jetbrains.skija.FontStyleSet
import org.jetbrains.skija.FontSlant
import org.jetbrains.skija.FontWidth
import org.jetbrains.skija.FontVariation
import org.jetbrains.skija.FontVariationAxis
import org.jetbrains.skija.GradientStyle
import org.jetbrains.skija.MaskFilter
import org.jetbrains.skija.OutputWStream
import org.jetbrains.skija.PaintMode
import org.jetbrains.skija.PaintStrokeCap
import org.jetbrains.skija.PaintStrokeJoin
import org.jetbrains.skija.PathEffect
import org.jetbrains.skija.PaintFilterCanvas
import org.jetbrains.skija.PathSegment
import org.jetbrains.skija.PathOp
import org.jetbrains.skija.PathFillMode
import org.jetbrains.skija.PathVerb
import org.jetbrains.skija.PathEllipseArc
import org.jetbrains.skija.PathDirection
import org.jetbrains.skija.PathSegmentIterator
import org.jetbrains.skija.RSXform
import org.jetbrains.skija.PathMeasure
import org.jetbrains.skija.PictureRecorder
import org.jetbrains.skija.PixelGeometry
import org.jetbrains.skija.Point3
import org.jetbrains.skija.RuntimeEffect
import org.jetbrains.skija.ShadowUtils
import org.jetbrains.skija.SurfaceOrigin
import org.jetbrains.skija.SurfaceColorFormat
import org.jetbrains.skija.TextBlobBuilder
import java.util.*

/**
 *
 * Matrix holds a 3x3 matrix for transforming coordinates. This allows mapping
 * Point and vectors with translation, scaling, skewing, rotation, and
 * perspective.
 *
 *
 * Matrix includes a hidden variable that classifies the type of matrix to
 * improve performance. Matrix is not thread safe unless getType() is called first.
 *
 * @see [https://fiddle.skia.org/c/@Matrix_063](https://fiddle.skia.org/c/@Matrix_063)
 */
class Matrix33(vararg mat: Float) {
    /**
     *
     * Matrix33 elements are in row-major order.
     *
     * <pre>`
     * | scaleX   skewX  transX |
     * |  skewY  scaleY  transY |
     * | persp0  persp1  persp2 |
    `</pre> *
     */
    /**
     *
     * Matrix33 elements are in row-major order.
     *
     * <pre>`
     * | scaleX   skewX  transX |
     * |  skewY  scaleY  transY |
     * | persp0  persp1  persp2 |
    `</pre> *
     */
    @ApiStatus.Internal
    val mat: FloatArray
    fun makePreScale(sx: Float, sy: Float): Matrix33 {
        return Matrix33(
            *floatArrayOf(
                mat[0] * sx,
                mat[1] * sy,
                mat[2],
                mat[3] * sx,
                mat[4] * sy,
                mat[5],
                mat[6] * sx,
                mat[7] * sy,
                mat[8]
            )
        )
    }

    /**
     *
     * Creates Matrix33 by multiplying this by other. This can be thought of mapping by other before applying Matrix.
     *
     *
     * Given:
     *
     * <pre>`
     * | A B C |          | J K L |
     * this = | D E F |, other = | M N O |
     * | G H I |          | P Q R |
    `</pre> *
     *
     *
     * Returns:
     *
     * <pre>`
     * | A B C |   | J K L |   | AJ+BM+CP AK+BN+CQ AL+BO+CR |
     * this * other = | D E F | * | M N O | = | DJ+EM+FP DK+EN+FQ DL+EO+FR |
     * | G H I |   | P Q R |   | GJ+HM+IP GK+HN+IQ GL+HO+IR |
    `</pre> *
     *
     * @param other  Matrix on right side of multiply expression
     * @return       this multiplied by other
     */
    fun makeConcat(other: Matrix33): Matrix33 {
        return Matrix33(
            *floatArrayOf(
                mat[0] * other.mat[0] + mat[1] * other.mat[3] + mat[2] * other.mat[6],
                mat[0] * other.mat[1] + mat[1] * other.mat[4] + mat[2] * other.mat[7],
                mat[0] * other.mat[2] + mat[1] * other.mat[5] + mat[2] * other.mat[8],
                mat[3] * other.mat[0] + mat[4] * other.mat[3] + mat[5] * other.mat[6],
                mat[3] * other.mat[1] + mat[4] * other.mat[4] + mat[5] * other.mat[7],
                mat[3] * other.mat[2] + mat[4] * other.mat[5] + mat[5] * other.mat[8],
                mat[6] * other.mat[0] + mat[7] * other.mat[3] + mat[8] * other.mat[6],
                mat[6] * other.mat[1] + mat[7] * other.mat[4] + mat[8] * other.mat[7],
                mat[6] * other.mat[2] + mat[7] * other.mat[5] + mat[8] * other.mat[8]
            )
        )
    }

    /**
     *
     * When converting from Matrix33 to Matrix44, the third row and
     * column remain as identity:
     *
     * <pre>`
     * [ a b c ]      [ a b 0 c ]
     * [ d e f ]  ->  [ d e 0 f ]
     * [ g h i ]      [ 0 0 1 0 ]
     * [ g h 0 i ]
    `</pre> *
     */
    fun asMatrix44(): Matrix44 {
        return Matrix44(mat[0], mat[1], 0, mat[2], mat[3], mat[4], 0, mat[5], 0, 0, 1, 0, mat[6], mat[7], 0, mat[8])
    }

    override fun equals(o: Any?): Boolean {
        if (o === this) return true
        if (o !is Matrix33) return false
        val other = o
        if (!other.canEqual(this as Any)) return false
        return if (!Arrays.equals(mat, other.mat)) false else true
    }

    protected fun canEqual(other: Any?): Boolean {
        return other is Matrix33
    }

    override fun hashCode(): Int {
        val PRIME = 59
        var result = 1
        result = result * PRIME + Arrays.hashCode(mat)
        return result
    }

    override fun toString(): String {
        return "Matrix33(_mat=" + Arrays.toString(mat) + ")"
    }

    companion object {
        /**
         * An identity Matrix33:
         *
         * <pre>`
         * | 1 0 0 |
         * | 0 1 0 |
         * | 0 0 1 |
        `</pre> *
         */
        val IDENTITY = makeTranslate(0f, 0f)

        /**
         *
         * Creates a Matrix33 to translate by (dx, dy). Returned matrix is:
         *
         * <pre>`
         * | 1 0 dx |
         * | 0 1 dy |
         * | 0 0  1 |
        `</pre> *
         *
         * @param dx  horizontal translation
         * @param dy  vertical translation
         * @return    Matrix33 with translation
         */
        @Contract("_, _ -> new")
        fun makeTranslate(dx: Float, dy: Float): Matrix33 {
            return Matrix33(*floatArrayOf(1f, 0f, dx, 0f, 1f, dy, 0f, 0f, 1f))
        }

        /**
         *
         * Creates a Matrix33 to scale by s. Returned matrix is:
         *
         * <pre>`
         * | s 0 0 |
         * | 0 s 0 |
         * | 0 0 1 |
        `</pre> *
         *
         * @param s  scale factor
         * @return   Matrix33 with scale
         */
        fun makeScale(s: Float): Matrix33 {
            return makeScale(s, s)
        }

        /**
         *
         * Creates a Matrix33 to scale by (sx, sy). Returned matrix is:
         *
         * <pre> `
         * | sx  0  0 |
         * |  0 sy  0 |
         * |  0  0  1 |
        `</pre> *
         *
         * @param sx horizontal scale factor
         * @param sy vertical scale factor
         * @return   Matrix33 with scale
         */
        fun makeScale(sx: Float, sy: Float): Matrix33 {
            return Matrix33(*floatArrayOf(sx, 0f, 0f, 0f, sy, 0f, 0f, 0f, 1f))
        }

        /**
         * Creates a Matrix33 to rotate by |deg| about a pivot point at (0, 0).
         *
         * @param deg  rotation angle in degrees (positive rotates clockwise)
         * @return     Matrix33 with rotation
         */
        fun makeRotate(deg: Float): Matrix33 {
            val rad = Math.toRadians(deg.toDouble())
            var sin = Math.sin(rad)
            var cos = Math.cos(rad)
            val tolerance = (1.0f / (1 shl 12)).toDouble()
            if (Math.abs(sin) <= tolerance) sin = 0.0
            if (Math.abs(cos) <= tolerance) cos = 0.0
            return Matrix33(
                *floatArrayOf(
                    cos.toFloat(),
                    (-sin).toFloat(),
                    0f,
                    sin.toFloat(),
                    cos.toFloat(),
                    0f,
                    0f,
                    0f,
                    1f
                )
            )
        }

        /**
         * Creates a Matrix33 to rotate by |deg| about a pivot point at pivot.
         *
         * @param deg    rotation angle in degrees (positive rotates clockwise)
         * @param pivot  pivot point
         * @return       Matrix33 with rotation
         */
        fun makeRotate(deg: Float, pivot: Point): Matrix33 {
            return makeRotate(deg, pivot._x, pivot._y)
        }

        /**
         * Creates a Matrix33 to rotate by |deg| about a pivot point at (pivotx, pivoty).
         *
         * @param deg     rotation angle in degrees (positive rotates clockwise)
         * @param pivotx  x-coord of pivot
         * @param pivoty  y-coord of pivot
         * @return        Matrix33 with rotation
         */
        fun makeRotate(deg: Float, pivotx: Float, pivoty: Float): Matrix33 {
            val rad = Math.toRadians(deg.toDouble())
            var sin = Math.sin(rad)
            var cos = Math.cos(rad)
            val tolerance = (1.0f / (1 shl 12)).toDouble()
            if (Math.abs(sin) <= tolerance) sin = 0.0
            if (Math.abs(cos) <= tolerance) cos = 0.0
            return Matrix33(
                *floatArrayOf(
                    cos.toFloat(),
                    (-sin).toFloat(),
                    (pivotx - pivotx * cos + pivoty * sin).toFloat(),
                    sin.toFloat(),
                    cos.toFloat(),
                    (pivoty - pivoty * cos - pivotx * sin).toFloat(),
                    0f,
                    0f,
                    1f
                )
            )
        }

        /**
         *
         * Creates a Matrix33 to skew by (sx, sy). Returned matrix is:
         *
         * <pre> `
         * | 1  sx  0 |
         * | sy  1  0 |
         * |  0  0  1 |
        `</pre> *
         *
         * @param sx horizontal skew factor
         * @param sy vertical skew factor
         * @return   Matrix33 with skew
         */
        fun makeSkew(sx: Float, sy: Float): Matrix33 {
            return Matrix33(*floatArrayOf(1f, sx, 0f, sy, 1f, 0f, 0f, 0f, 1f))
        }
    }

    init {
        assert(mat.size == 9) { (if ("Expected 9 elements, got $mat" == null) null else mat.size)!! }
        this.mat = mat
    }
}